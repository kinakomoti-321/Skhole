#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_ARB_shading_language_include : require

#include "./payload.glsl"

//layout(location = 0) rayPayloadEXT vec3 payload;
layout(location = 0) rayPayloadEXT PayLoadStruct payload;

layout(binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, rgba8) uniform image2D image;

#define PI 3.14159265359

layout(binding = 2) uniform UBO {
    uint spp;
    uint frame;

    uint width;
    uint height;

    vec3 cameraPos;
    vec3 cameraDir;
    vec3 cameraUp;
    vec3 cameraRight;

    vec4 cameraParam;
} ubo;

struct Ray{
    vec3 origin;
    vec3 direction;
};

vec3 GetPinholeCameraDir(vec3 cameraDir,vec3 cameraUp,vec3 cameraRight,vec2 uv, float f){
    return normalize(uv.y * cameraUp + uv.x * cameraRight + f * cameraDir);
}

void main()
{
    vec2 uv = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
    float aspect = ubo.cameraParam.y;
    uv.x *= aspect;

    vec3 origin = ubo.cameraPos;
    vec3 target = vec3(uv * 2.0 - 1.0, 2);
    vec3 direction = normalize(target - origin);
    Ray ray;
    ray.origin = ubo.cameraPos;
        
    float fov = ubo.cameraParam.x;
    float f = 1.0 / (atan(fov * 0.5 * PI / 180.0f));

    ray.direction = GetPinholeCameraDir(
        ubo.cameraDir,
        ubo.cameraUp,
        ubo.cameraRight,
        uv * 2.0 - 1.0,
        f
    );
     

    payload.basecolor = vec3(0);
    payload.normal = vec3(0);
    payload.isMiss = false;

    traceRayEXT(
        topLevelAS,
        gl_RayFlagsOpaqueEXT,
        0xff,       // cullMask
        0, 0, 0,    // sbtRecordOffset, sbtRecordStride, missIndex
        ray.origin,
        0.001,      // tMin
        ray.direction,
        10000.0,    // tMax
        0           // payloadLocation
    );

    vec3 col = payload.basecolor;
    if(payload.isMiss) col = vec3(0.0);

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col,0.0));
}
