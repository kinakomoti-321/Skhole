#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_ARB_shading_language_include : require
#extension GL_EXT_scalar_block_layout : enable

#define PI 3.14159265359

#include "./payload.glsl"
#include "../common/hash.glsl"
#include "../common/math.glsl"
#include "../common/bsdf.glsl"

layout(location = 0) rayPayloadEXT PayLoadStruct payload;

layout(binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, rgba8) uniform image2D image;

layout(binding = 2, rgba32f) uniform image2D accumImage;

layout(binding = 3, scalar) uniform UBO {
    uint maxSPP;
    uint numSPP;
    uint sppPerFrame;
    uint frame;
    uint resetFlag;
    uint mode;

    uint width;
    uint height;

    vec3 cameraPos;
    vec3 cameraDir;
    vec3 cameraUp;
    vec3 cameraRight;

    vec4 cameraParam;

    vec3 lightPos;
    vec4 lightcol;
    float lightintensity;

} ubo;

struct VertexData{
	vec4 position;
	vec4 normal;
	vec2 texcoord0;
	vec2 texcoord1;
	vec4 color;
};

struct GeometryData{
	int vertexOffset;
	int indexOffset;
};

struct InstanceData{
	uint geometryIndex;

	vec4 transform0;
	vec4 transform1;
	vec4 transform2;

	vec4 normalTransform0;
	vec4 normalTransform1;
	vec4 normalTransform2;
};

struct Material{
	vec4 baseColor;
	float anisotropic;
	float roughness;
	float metallic;

	float emissionPower;
	vec4 emissionColor;

	int isGlass;
	float ior;
};

layout(std430, binding = 4) buffer readonly vertexData{
	VertexData vertex[];
};

layout(std430, binding = 5) buffer readonly indexData{
	uint index[];
};

layout(scalar, binding = 6) buffer readonly geometryData{
	GeometryData geometry[];
};

layout(scalar, binding = 7) buffer readonly instanceData{
	InstanceData instance[];
};

layout(scalar,binding = 8) buffer readonly materialData{
	Material materials[];
};

layout(std430, binding = 9) buffer readonly matIndexData{
	uint matIndex[];
};

struct Ray{
    vec3 origin;
    vec3 direction;
};

vec3 GetPinholeCameraDir(vec3 cameraDir,vec3 cameraUp,vec3 cameraRight,vec2 uv, float f){
    return normalize(uv.y * cameraUp + uv.x * cameraRight + f * cameraDir);
}

struct BSDFParameter
{
vec3 basecolor;
float metallic;
float roughness;
float anisotropic;

bool isGlass;
float ior;

bool isSand;
};

float ComplexBSDF_PDF(vec3 wo, inout vec3 wi, BSDFParameter param){
    GGX_Params ggxParam;
    ggxParam.F0 = param.basecolor;
    ggxParam.roughness = param.roughness;
    ggxParam.anisotropic = param.anisotropic;

    float diffuseWeight = (1.0 - param.metallic);  
    float specularWeight = 1.0;

    float sumWeight = diffuseWeight + specularWeight;

    float diffusePDF = diffuseWeight / sumWeight;
    float specularPDF = specularWeight / sumWeight;

    float dp = LambertBSDF_PDF(wo,wi);
    float sp = GGX_PDF(wo,wi,ggxParam);
    
    float pdf = dp * diffusePDF + sp * specularPDF;

    return pdf;
}

vec3 ComplexBSDF_Evaluate(vec3 wo, vec3 wi, BSDFParameter param){
    GGX_Params ggxParam;
    ggxParam.F0 = mix(vec3(0.04),param.basecolor, param.metallic);
    ggxParam.roughness = param.roughness;
    ggxParam.anisotropic = param.anisotropic;

    vec3 diffuse = LambertBSDF_Evaluation(wo,wi,param.basecolor);
    vec3 specular = GGX_Evaluation(wo,wi,ggxParam);

    return (1.0f - param.metallic) * diffuse + specular;
}

vec3 ComplexBSDF_Sample(vec3 wo, inout vec3 wi, BSDFParameter param, inout float pdf){
    float diffuseWeight = (1.0 - param.metallic);  
    float specularWeight = 1.0;

    float sumWeight = diffuseWeight + specularWeight;

    float diffusePDF = diffuseWeight / sumWeight;
    float specularPDF = specularWeight / sumWeight;

    float sampleSelectP = rnd1();

    float dp;
    float sp;

    GGX_Params ggxParam;
    ggxParam.F0 = param.basecolor;
    ggxParam.roughness = param.roughness;
    ggxParam.anisotropic = param.anisotropic;

    vec2 xi = rnd2();
    if(sampleSelectP <= diffusePDF){
        wi = LambertBSDF_Sample(wo, dp, xi);
        sp = GGX_PDF(wo,wi,ggxParam);
	}
    else{
        wi = GGX_Sample(wo, sp, ggxParam, xi); 
        dp = LambertBSDF_PDF(wo,wi);
    }

    if(wi.y < 0.0){
        pdf = 0.0;
		return vec3(0.0);
	}
    
    pdf = dp * diffusePDF + sp * specularPDF;

    return ComplexBSDF_Evaluate(wo,wi,param);
}

vec3 BSDF_Evaluate(vec3 wo, vec3 wi, BSDFParameter param)
{
    if(param.isGlass){
        return vec3(0.0);
    }
    else
    {
        return ComplexBSDF_Evaluate(wo,wi, param);
    }
}

float BSDF_PDF(vec3 wo, inout vec3 wi, BSDFParameter param)
{
    if(param.isGlass){
		return 0.0;
	}
	else
	{
        return ComplexBSDF_PDF(wo,wi,param);
    }
}

vec3 BSDF_Sample(vec3 wo, inout vec3 wi, BSDFParameter param, inout float pdf)
{
    if(param.isGlass){
        pdf = 1.0; 
        return IdealRefractionBTDF_Sample(wo,wi,param.ior,rnd2());    
	}
	else
	{
        return ComplexBSDF_Sample(wo,wi,param,pdf);
    }
}

void Raytrace(Ray ray, float minT, float maxT){
	traceRayEXT(
		topLevelAS,
		gl_RayFlagsOpaqueEXT,
		0xff,       
		0, 0, 0,  
		ray.origin,
		minT,     
		ray.direction,
		maxT,   
		0       
	);
}

// A x^2 + B x + C = 0
int QuadricSolver(float A, float B, float C,inout float sol1,inout float sol2){
    int solCount = 0;
    float D = B * B - 4.0 * A * C;
    if(D < 0){
        sol1 = -10000;
        sol2 = -10000;
        return 0;
    }
    if(abs(D) < 0.0001){
        // Multiple Root
        sol1 = - B / (A*2);
        sol2 = -10000;
        return 1;
    }

    sol1 = (- B + sqrt(D)) / (A*2);
    sol2 = (- B - sqrt(D)) / (A*2);

    return 2;
}

vec2 ConvertBarycetric(float a, int index){
    vec2 barycentric;
    if(index == 0){
        // Beta = 0;
        barycentric = vec2(a,0);
    }
    else if(index == 1){
        // Alpha + Beta = 1
        barycentric = vec2(1 - a,a);
    }
    else if(index == 2){
       // Alpha = 0 
       barycentric = vec2(0,a);
    }

    return barycentric;
}

void SolveTriangle(vec3 v[3], vec3 n[3], vec3 L, vec3 P, inout vec2 sol_bary[2],inout int sol_count,inout float sol_sign[2],inout int edge_index[2]){
    vec3 v0 = v[0];
    vec3 v1 = v[1];
    vec3 v2 = v[2];

    vec3 n0 = n[0];
    vec3 n1 = n[1];
    vec3 n2 = n[2];

    mat3 mN = mat3(n0,n1,n2);

    vec3 PL = L - P;
    vec3 V0V1 = v1 - v0;
    vec3 V0V2 = v2 - v0;
    vec3 PV0 = v0 - P;

    mat3 mQ = mat3(cross(PL,V0V1), cross(PL,V0V2), cross(PL,PV0));
    mQ = transpose(mQ);

    mat3 mCoplaner = mN * mQ;

    // A a^2 + B b^2 + C ab + D a + E b + F = 0
    float A = mCoplaner[0][0];
    float B = mCoplaner[1][1];
    float C = mCoplaner[0][1] + mCoplaner[1][0];
    float D = mCoplaner[0][2] + mCoplaner[2][0];
    float E = mCoplaner[1][2] + mCoplaner[2][1];
    float F = mCoplaner[2][2];

    int count = 0;
    vec2 sol[2];
    int edgeIndex[2];

    // Alpha
    float quadA[3] = {A,A+B-C,B};
    float quadB[3] = {D,C + E - 2.0 * A - D,E};
    float quadC[3] = {F,A + D + F,F};

    float testSol[6];

    int counts[3];
    for(int i = 0; i < 3; i++){

        float solusions[2]; 
        int solCount = QuadricSolver(quadA[i], quadB[i], quadC[i],solusions[0],solusions[1]);

        testSol[i * 2] = solusions[0];
        testSol[i * 2 + 1] = solusions[1];
        counts[i] = solCount;
        if(solCount == 0) continue;

        for(int j = 0; j < 2; j++){
            if(solusions[j] < 1 && solusions[j] > 0){
                sol[count] = ConvertBarycetric(solusions[j],i);
                edgeIndex[count] = i;
                count++;
            }

            if(count == 2) break;
        }
    }

    // Tangent
    vec3 tangent[2];
    float tanSign[2];

    mat3 mConicMatrix = mat3(A, 0.5 * C, 0.5 * D,
                                0.5 * C, B, 0.5 * E,
                                0.5 * D, 0.5 * E, F);

    for(int i = 0; i < 2; i++){
        vec3 solusionVector = vec3(sol[i].x,sol[i].y,1);
        vec3 curveBinormal = transpose(mConicMatrix) * solusionVector;

        vec3 pM = (1.0 - sol[i].x - sol[i].y) * v0 + sol[i].x * v1 + sol[i].y * v2;
        vec3 nM = (1.0 - sol[i].x - sol[i].y) * n0 + sol[i].x * n1 + sol[i].y * n2;

        vec3 wo = normalize(P - pM);
        vec3 wi_ref = refract(-wo,nM, 1.33 / 1.0);
        vec3 wi = normalize(L - pM);

        tangent[i] = normalize(vec3(-curveBinormal.y,curveBinormal.x,0)); 
        
        float s = sign(dot(tangent[i],cross(wi_ref,wi)));
        tanSign[i] = s; 
    }

    sol_bary = sol;
    sol_count = count;
    sol_sign = tanSign;
    edge_index = edgeIndex;
}

int GetSolTypeIndex(int edgeIndex[2]){
    int index_min = min(edgeIndex[0], edgeIndex[1]);
    int index_max = max(edgeIndex[0], edgeIndex[1]);

    return (index_min + index_max) - 1;
}

vec2 DivBaryCoord(int solTypeIndex){
    vec2 bary;
    if(solTypeIndex == 0){
        bary = vec2(0.0,0.5);
    }
    else if(solTypeIndex == 1){
        bary = vec2(0.5,0.5);
    }
    else if(solTypeIndex == 2){
        bary = vec2(0.5,0.0);
    }

    return bary;
}

void DivideTriangle(vec3 v[3], vec3 n[3], vec2 bary, int solTypeIndex,inout vec3 prim1_v[3],inout vec3 prim1_n[3],inout vec3 prim2_v[3],inout vec3 prim2_n[3]){
    vec3 div_v = (1.0 - bary.x - bary.y) * v[0] + bary.x * v[1] + bary.y * v[2];
    vec3 div_n = (1.0 - bary.x - bary.y) * n[0] + bary.x * n[1] + bary.y * n[2];

    int index[3];
    if(solTypeIndex == 0){
        index[0] = 1;
        index[1] = 2;
        index[2] = 0;
    }
    else if(solTypeIndex == 1){
        index[0] = 0;
        index[1] = 1;
        index[2] = 2;
    }
    else if(solTypeIndex == 2){
        index[0] = 2;
        index[1] = 0;
        index[2] = 1;
    }

    prim1_v[0] = v[index[0]];
    prim1_v[1] = v[index[1]];
    prim1_v[2] = div_v;
    prim1_n[0] = n[index[0]];
    prim1_n[1] = n[index[1]];
    prim1_n[2] = div_n;

    prim2_v[0] = v[index[0]];
    prim2_v[1] = div_v;
    prim2_v[2] = v[index[2]];
    prim2_n[0] = n[index[0]];
    prim2_n[1] = div_n;
    prim2_n[2] = n[index[2]];
}

bool SearchCausticsPath(vec3 L, vec3 P, vec3 v[3], vec3 n[3], inout vec3 pos, inout vec3 norm){
    vec2 sol_bary[2];
    int sol_count;
    float sol_sign[2];
    int edge_index[2];

    SolveTriangle(v,n,L,P,sol_bary,sol_count,sol_sign,edge_index);

    if(sol_count != 2) return false;
    if(sol_sign[0] * sol_sign[1] > 0) return false;

    //Divide
    int iteration = 1;

    vec3 next_v[3];
    next_v = v;
    vec3 next_n[3];
    next_n = n;

    vec3 endP;
    vec3 endN;

    int div_edge_index[] = edge_index;

    for(int i = 0; i < iteration; i++){
        int solTypeIndex = GetSolTypeIndex(div_edge_index);
        vec2 divBary =  DivBaryCoord(solTypeIndex);

        vec3 prim1_v[3];
        vec3 prim1_n[3];

        vec3 prim2_v[3];
        vec3 prim2_n[3];

        DivideTriangle(next_v,next_n,divBary,solTypeIndex,prim1_v,prim1_n,prim2_v,prim2_n);

        vec2 div_sol_bary[2];
        int div_sol_count;
        float div_sol_sign[2];

        SolveTriangle(prim1_v,prim1_n,L,P,div_sol_bary,div_sol_count,div_sol_sign,div_edge_index);

        if(i == iteration - 1){
            vec2 end_bary = div_sol_bary[0];
            endP = (1.0 - end_bary.x - end_bary.y) * next_v[0] + end_bary.x * next_v[1] + end_bary.y * next_v[2];
            endN = (1.0 - end_bary.x - end_bary.y) * next_n[0] + end_bary.x * next_n[1] + end_bary.y * next_n[2];
        }

        if(div_sol_sign[0] * div_sol_sign[1] <= 0){
            next_v = prim1_v;
            next_n = prim1_n;
        }
        else{
            next_v = prim2_v;
            next_n = prim2_n;
        }
    }

    pos = endP;
    norm = endN;
    return true;
}


vec3 EvaluateCausticsPath(vec3 Point, vec3 LightPos,uint instanceID,uint primID, float ior){

	InstanceData inst = instance[instanceID];
	GeometryData geom = geometry[inst.geometryIndex];

	uint index0 = index[geom.indexOffset + primID * 3 + 0];
	uint index1 = index[geom.indexOffset + primID * 3 + 1];
	uint index2 = index[geom.indexOffset + primID * 3 + 2];

	VertexData vert[3];
	vert[0] = vertex[geom.vertexOffset + index0];
	vert[1] = vertex[geom.vertexOffset + index1];
	vert[2] = vertex[geom.vertexOffset + index2];

    mat4 transform = mat4(
		inst.transform0.x, inst.transform1.x, inst.transform2.x, 0.0,
		inst.transform0.y, inst.transform1.y, inst.transform2.y, 0.0,
		inst.transform0.z, inst.transform1.z, inst.transform2.z, 0.0,
		inst.transform0.w, inst.transform1.w, inst.transform2.w, 1.0
	);

	mat4 normalTransform = mat4(
		inst.normalTransform0.x, inst.normalTransform1.x, inst.normalTransform2.x, 0.0,
		inst.normalTransform0.y, inst.normalTransform1.y, inst.normalTransform2.y, 0.0,
		inst.normalTransform0.z, inst.normalTransform1.z, inst.normalTransform2.z, 0.0,
		inst.normalTransform0.w, inst.normalTransform1.w, inst.normalTransform2.w, 1.0
	);

    vec3 v[3];
    vec3 n[3];

    v[0] = (transform * vert[0].position).xyz;
    v[1] = (transform * vert[1].position).xyz;
    v[2] = (transform * vert[2].position).xyz;

    n[0] = (normalTransform * vert[0].normal).xyz;
    n[1] = (normalTransform * vert[1].normal).xyz;
    n[2] = (normalTransform * vert[2].normal).xyz;

    vec3 pos;
    vec3 norm;

    vec3 L = LightPos;
    vec3 P = Point;

    bool check =  SearchCausticsPath(L,P,v,n,pos,norm);

    if(check){
        return vec3(1.0);
    }
    else{
		return vec3(0.0);
	}
}

vec3 Pathtrace(Ray ray, inout vec3 fBaseColor, inout vec3 fNormal)
{
    vec3 LTE = vec3(0.0);
    vec3 throughput = vec3(1.0);
    float p0 = 1.0;

    for(int depth = 0; depth < 5; depth++){
        p0 = min(max(max(throughput.x,throughput.y),throughput.z),1.0); 
        if(p0 < rnd1()){
            break;
        }
        throughput /= p0;

        Raytrace(ray,0.001,10000.0);

        if(payload.isMiss)
        {
            LTE += throughput * vec3(0.0);
            break;
        }

        if(depth == 0){
            fBaseColor = payload.basecolor;
            fNormal = payload.normal;
        }

        if(payload.isLight){
            LTE += throughput * payload.emission; 
            break;
        }
        
        vec3 position = payload.position;
        vec3 normal = payload.normal;
        
        vec3 wo = -ray.direction; 
        
        vec3 t,b;
        tangentSpaceBasis(normal,t,b);
        
        float pdf;

        vec3 localwo = worldtoLoacal(wo,t,normal,b);
        vec3 localwi;

        vec3 basecolor = payload.basecolor;
        float metallic = payload.metallic;
        float roughness = payload.roughness;
        float anisotropic = payload.anisotropic;
        vec2 xi = rnd2();
        vec3 bsdf;

        BSDFParameter bsdfParam;
        bsdfParam.basecolor = basecolor;
        bsdfParam.metallic = metallic;
        bsdfParam.roughness = roughness;
        bsdfParam.anisotropic = anisotropic;
        bsdfParam.isGlass = payload.isGlass;
        bsdfParam.ior = payload.ior;

        bsdf = BSDF_Sample(localwo,localwi,bsdfParam,pdf);
        {
            // Light
            vec3 lightDir = normalize(ubo.lightPos - position);
            vec3 lightEmission = ubo.lightcol.xyz * ubo.lightintensity; 

            float lightDistance = distance(ubo.lightPos,position);

            Ray shadowRay;
            shadowRay.origin = position;
            shadowRay.direction = lightDir;

            Raytrace(shadowRay,0.001,lightDistance - 0.001);

            if(payload.isMiss){
				vec3 localLightDir = worldtoLoacal(lightDir,t,normal,b);
				vec3 lightBSDF = BSDF_Evaluate(localwo,localLightDir, bsdfParam);
				float cosine = abs(localLightDir.y);
				LTE += throughput * lightEmission * lightBSDF * cosine / (lightDistance * lightDistance);
            }
            else if(payload.isGlass)
            {
               LTE += throughput * EvaluateCausticsPath(position, ubo.lightPos ,payload.instanceID,payload.primID,payload.ior) * lightEmission; 
            }
        }
        vec3 wi = localToWorld(localwi,t,normal,b);

        float cosine = abs(localwi.y);
        throughput *= bsdf * cosine / pdf;

        ray.direction = wi;
        ray.origin = position + wi * 0.001;

    }
    
    return LTE;
}

void main()
{
    seed = ((gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * ubo.width) + 1) * (ubo.numSPP + 1);


    payload.basecolor = vec3(0);
    payload.normal = vec3(0);
    payload.isMiss = false;
    payload.isLight = false;
    payload.emission = vec3(0);

    vec3 sumLTE = vec3(0);
    vec3 sumBaseColor = vec3(0);
    vec3 sumNormal = vec3(0);

    int spf = int(ubo.sppPerFrame);
    int spp = int(ubo.numSPP);
    int maxSPP = int(ubo.maxSPP);

    for(int s = 0; s < spf; s++){
        if(spp >= maxSPP){
			break;
		}

		vec2 uv = (vec2(gl_LaunchIDEXT.xy + rnd2()) * 2.0 - gl_LaunchSizeEXT.xy) / vec2(gl_LaunchSizeEXT.y);
		uv.y  = -uv.y;

		vec3 origin = ubo.cameraPos;

		Ray ray;
		ray.origin = ubo.cameraPos;
			
		float fov = ubo.cameraParam.x;
		float f = 1.0 / (atan(fov * 0.5 * PI / 180.0f));

		ray.direction = GetPinholeCameraDir(
			ubo.cameraDir,
			ubo.cameraUp,
			ubo.cameraRight,
			uv,
			f
		);

		vec3 fBaseColor = vec3(0.0);
		vec3 fNormal = vec3(0.0);
		vec3 LTE = Pathtrace(ray,fBaseColor,fNormal);
        if(isnan(LTE.x) || isnan(LTE.y) || isnan(LTE.z)){
            LTE = vec3(0.0);
		}

		sumLTE += LTE;
		sumBaseColor += fBaseColor;
		sumNormal += fNormal;
        spp++;
	}

    vec3 accumLTE = vec3(0.0);
    if(ubo.numSPP != 0){
        // Accumulate
        accumLTE += imageLoad(accumImage, ivec2(gl_LaunchIDEXT.xy)).xyz;
    }

    accumLTE += sumLTE;

    imageStore(accumImage,ivec2(gl_LaunchIDEXT.xy), vec4(accumLTE,0.0));
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(accumLTE,0.0) / float(spp));
}
